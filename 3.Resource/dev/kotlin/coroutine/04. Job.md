작업 관계에서 작업간 종속성이 있는 작업들이 존재 -> 선행 작업이 완료 될 때 까지 기다린 후 후행 작업 실행

#### join 
> join을 통해 메서드 완료시점을 기다린 후 후속작업을 실행하는 방식 
> join을 호출할 경우 join 코루틴이 완료될 때 까지 기다린 후 join 메서드를 호출한 코루틴이 실행됨


```
fun main () = runBlocking<Unit> {
	val jobA = launch(Dispatchers.IO) {
		delay(1000L)  // 시간이 걸리는 작업이라 가정
		println("do A")
	}

	jobA.join()

	val jobB = launch(Dispatchers.IO) {
		println("Then, do B")
	}
}
```

#### joinAll 
> 여러가지의 코루틴을 기다려야 할 때, 사용하는 메서드

```
public suspend fun joinAll(varag jobs: Job): Unit = jobs.forEach { it.join() }
```

```
fun main () = runBlocking<Unit> {
	val jobA_1 = launch(Dispatchers.IO) {
		delay(1000L)  // 시간이 걸리는 작업이라 가정
		println("do A_1")
	}

	val jobA_2 = launch(Dispatchers.IO) {
		delay(1000L)  // 시간이 걸리는 작업이라 가정
		println("do A_2")
	}

	joinAll(jobA_1, jobA_2)

	val jobB = launch(Dispatchers.IO) {
		println("Then, do B")
	}
}
```


### 지연 코루틴 
> 지연 코루틴은 즉시 실행 요청되지 않는 코루틴
> launch 함수의 start 인자에 CoroutineStart.LAZY를 입력 해 주 ㄷ