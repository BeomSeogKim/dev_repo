**분할 정복 전략**
- 큰 작업을 작은 단위로 재귀적으로 분할 (fork)
- 각 작은 작업의 결과를 합쳐 최종 결과를 생성 (join)
- 멀티코어 환경에서 작업을 효율적으로 분산 처리
**작업 훔치기 알고리즘**
- 각 스레드는 자신의 작업 큐를 가짐
- 작업이 없는 스레드는 다른 바쁜 스레드의 큐에서 작업을 훔쳐와 대신 처리
- 부하 균형을 자동으로 조절하여 효율성 향상.

### 적절한 작업 크기
- 이상적인 작업 크기 방식 : 한 스레드 당 1개의 작업 처리
- 실제 고려 크기 방식 : 한 스레드 당 1개 이상의 작업을 처리할 수 있도록
	- 만약 다른 스레드에서 실행 시간이 오래 걸릴 경우 다른 스레드에서 도와 줄 수 있기 때문에.

### Common Pool
특징
- 시스템 전체에서 공유 : 애플리케이션 내에서 단일 인스턴스로 공유되어 사용됨
- 자동 생성 : 별도 생성없이 ForkJoinPool.commonPool()을 통해 접근이 가능함
- 편리한 사용 : 별도의 풀을 만들지 않고, RecursiveTask / RecursiveAction을 사용할 때, 기본적으로 commonPool이 사용됨
- 병렬 스트림 활용 : 자바 8의 병렬 스트림은 내부적으로 commonPool을 사용
- 자원 효율성 : 여러 곳에서 별도의 풀을 생성하는 대신 공용 풀을 사용함으로써 시스템 자원을 효율적으로 관리할 수 있음
- 병렬 수준 자동 설정 : 기본적으로 시스템의 가용 프로세서 수에서 1을 뺀 값으로 병렬 수준이 설정됨

주의점
- Fork/Join 프레임워크는 CPU Bound Task에서만 활용하자.
- I/O bound 작업에 commonPool을 사용하면 다음과 같은 문제가 발생
	- 스레드 블로킹에 따른 CPU 낭비
		- ForkJoinPool은 CPU 코어 수에 맞춰 제한된 개수의 스레드를 사용
		- I/O작업으로 스레드가 블로킹되면 CPU가 놀게되어, 병렬 처리 효율이 감소함
	- 컨텍스트 스위칭 오버헤드 증가
		- I/O 작업 때문에 스레드를 늘리면, 실제 연산보다 대기 시간이 길어지는 상황이 발생할 수 있음
		- 스레드가 많아질수록 컨텍스트 스위칭 비용도 증가해 오히려 성능이 감소할 수 있ㅇ므
	- 작업 훔치기 기법 무력화
		- I/O 대기 시간이 많은 작업은 스레드가 I/O로 인해 대기하고 있는 경우가 많아, 작업 훔치기가 빛을 발휘하기 어려움
